@page "/scan"
@model VideoIndex.Web.Pages.Scan.IndexModel

@{
    ViewData["Title"] = "Live Scan";
}

@await Html.PartialAsync("_TopNav")

<div class="scan-page">
    <h1>Live Scan</h1>

    <div class="row">
        <label for="rootSelect">Root:</label>
        <select id="rootSelect">
            @foreach (var r in Model.Roots)
            {
                <option value="@r.Id">@r.Name (@r.Path)</option>
            }
        </select>
        <button id="startBtn" class="btn primary">Start Scan</button>
        <button id="stopBtn" class="btn" style="display: none; background-color:#c62828;">Stop Scan</button>
        <span id="status" class="muted">idle</span>
    </div>

    <div class="row" style="width:100%;">
        <progress id="prog" value="0" max="100" style="width: 360px;"></progress>
        <span id="counts" class="muted"></span>
    </div>

    <pre id="log"></pre>

    <details class="edit-panel" style="margin-top: 1rem;">
        <summary><strong class="summary-text">Admin & Advanced Options</strong></summary>
        <div class="edit-body">
            <div class="row">
                <label class="hstack" style="font-weight:normal; cursor:pointer;">
                    <input id="newFilesOnly" type="checkbox" checked />
                    <span>Scan new files only (fast)</span>
                </label>
                <label class="hstack" style="font-weight:normal; cursor:pointer;">
                    <input id="autoTag" type="checkbox" checked />
                    <span>Enable auto-tagging</span>
                </label>
            </div>
            <div class="row">
                <label class="hstack" style="font-weight:normal; cursor:pointer;">
                    <input id="thumbs" type="checkbox" checked />
                    <span>Generate thumbnails</span>
                </label>
                <label class="hstack" style="font-weight:normal; cursor:pointer;">
                    <input id="regenAll" type="checkbox" />
                    <span>Regenerate ALL thumbnails (slow)</span>
                </label>
            </div>
            <div class="row">
                <div class="field hstack">
                    <label for="workers">Workers:</label>
                    <input id="workers" type="number" value="8" min="1" max="24" />
                </div>
            </div>
            <hr style="border: 0; border-top: 1px solid #ddd; margin: 1rem 0;" />
            <div class="row">
                <button id="generateMissingThumbsBtn" class="btn ghost">Generate Missing Thumbnails</button>
                <button id="cleanupTagsBtn" class="btn ghost">Cleanup 'x-auto-tagged'</button>
                <span id="adminStatus" class="muted"></span>
            </div>
        </div>
    </details>
</div>

<script src="https://unpkg.com/%40microsoft/signalr@latest/dist/browser/signalr.min.js"></script>
<script>
    const $ = sel => document.querySelector(sel);
    const logEl = $("#log");
    const statusEl = $("#status");
    const countsEl = $("#counts");
    const progEl = $("#prog");
    const startBtn = $("#startBtn");
    const stopBtn = $("#stopBtn");
    const newFilesOnlyCheck = $("#newFilesOnly");
    const autoTagCheck = $("#autoTag");
    const thumbsCheck = $("#thumbs");
    const regenAllCheck = $("#regenAll");
    const workersInput = $("#workers");
    const generateMissingThumbsBtn = $("#generateMissingThumbsBtn");
    const cleanupTagsBtn = $("#cleanupTagsBtn");
    const adminStatus = $("#adminStatus");

    let currentScanId = null;
    let connection = null;

    function log(msg, cls = "") {
        const time = new Date().toLocaleTimeString();
        const line = `[${time}] ${msg}\n`;
        const span = document.createElement("span");
        if (cls) span.className = cls;
        span.textContent = line;
        logEl.appendChild(span);
        logEl.scrollTop = logEl.scrollHeight;
    }

    function setStatus(txt) {
        statusEl.textContent = txt;
    }

    function resetUiState() {
        startBtn.disabled = false;
        generateMissingThumbsBtn.disabled = false;
        stopBtn.style.display = 'none';
        stopBtn.disabled = false;
        if(connection) {
            connection.stop();
            connection = null;
        }
        currentScanId = null;
    }
    
    // --- THIS IS THE CORRECTED LOGIC ---
    function updateOptionStates(changedInput) {
        if (changedInput === regenAllCheck) {
            if (regenAllCheck.checked) {
                // If regenerating all, force "scan all" and "generate thumbs"
                newFilesOnlyCheck.checked = false;
                newFilesOnlyCheck.disabled = true;
                thumbsCheck.checked = true;
                thumbsCheck.disabled = true;
            } else {
                // If turning off regen, re-enable the other options
                newFilesOnlyCheck.disabled = false;
                thumbsCheck.disabled = false;
            }
        }

        if (changedInput === newFilesOnlyCheck) {
            // "New files only" and "Regen all" are mutually exclusive
            regenAllCheck.disabled = newFilesOnlyCheck.checked;
             if (newFilesOnlyCheck.checked) {
                regenAllCheck.checked = false;
            }
        }
    }

    newFilesOnlyCheck.addEventListener('change', () => updateOptionStates(newFilesOnlyCheck));
    regenAllCheck.addEventListener('change', () => updateOptionStates(regenAllCheck));
    // --- END OF CORRECTION ---

    startBtn.addEventListener("click", async () => {
        startBtn.disabled = true;
        generateMissingThumbsBtn.disabled = true;
        stopBtn.style.display = 'inline-flex';
        logEl.innerHTML = "";
        setStatus("connecting…");

        const rootId = parseInt($("#rootSelect").value, 10);
        currentScanId = crypto.randomUUID();

        connection = new signalR.HubConnectionBuilder()
            .withUrl("/hubs/scan")
            .withAutomaticReconnect()
            .build();

        let totalFiles = 0;

        connection.on("progress", evt => {
            let { processed = 0, indexed = 0, tagged = 0, thumbsMade = 0, errors = 0 } = evt;
            countsEl.textContent = `${processed}/${totalFiles} | Indexed: ${indexed} | Tagged: ${tagged} | Thumbs: ${thumbsMade} | Errors: ${errors}`;
            progEl.value = processed;
          
            switch (evt.kind) {
                case "started":
                    totalFiles = evt.totals.files || 0;
                    progEl.max = Math.max(totalFiles, 1);
                    setStatus("running");
                    log(`Scan started on "${evt.root.name}" — found ${totalFiles} files to process.`, "muted");
                    break;
                case "indexError":
                    log(`Index error: ${evt.file} — ${evt.error}`, "err");
                    break;
                case "cancelled":
                    setStatus("stopped");
                    log(`Scan was stopped by user.`, "warn");
                    resetUiState();
                    break;
                case "completed":
                    setStatus("done");
                    log(`Completed in ${evt.elapsedMs} ms.`, "ok");
                    resetUiState();
                    break;
            }
        });

        try {
            await connection.start();
            await connection.invoke("JoinScan", currentScanId);
            log(`Joined scan channel ${currentScanId}`, "muted");

            const params = new URLSearchParams({
                scanId: currentScanId,
                newFilesOnly: newFilesOnlyCheck.checked,
                autoTag: autoTagCheck.checked,
                thumbs: thumbsCheck.checked,
                regenAll: regenAllCheck.checked,
                dop: workersInput.value
            });
            const url = `/api/roots/${rootId}/scan-live?${params.toString()}`;
            const resp = await fetch(url, { method: "POST" });
            if (!resp.ok) {
                const text = await resp.text();
                log(`Scan start failed: ${resp.status} ${text}`, "err");
                setStatus("error");
                resetUiState();
            }
        } catch (e) {
            log(`SignalR error: ${e}`, "err");
            setStatus("error");
            resetUiState();
        }
    });

    stopBtn.addEventListener("click", async () => {
        if (!currentScanId) return;
        setStatus("stopping…");
        stopBtn.disabled = true;
        await fetch(`/api/scan/${currentScanId}/stop`, { method: "POST" });
    });

    generateMissingThumbsBtn.addEventListener("click", async () => {
        adminStatus.textContent = "Requesting thumbnail generation...";
        startBtn.disabled = true;
        generateMissingThumbsBtn.disabled = true;
        logEl.innerHTML = "";

        const resp = await fetch('/api/media/generate-missing-thumbnails', { method: 'POST' });
        if (resp.ok) {
            const data = await resp.json();
            adminStatus.textContent = `Task started.`;
            currentScanId = data.scanId;
            connection = new signalR.HubConnectionBuilder().withUrl("/hubs/scan").build();
            
            connection.on("progress", evt => {
                 let { processed = 0, thumbsMade = 0 } = evt;
                 let total = evt.totals?.files || '?';
                 
                 progEl.value = processed;
                 countsEl.textContent = `${processed} / ${total} | Thumbs: ${thumbsMade}`;
                 
                 switch(evt.kind) {
                     case "started":
                        progEl.max = Math.max(total, 1);
                        log(`Generating missing thumbnails for ${total} files...`, "muted");
                        break;
                     case "completed":
                        log(`Thumbnail generation complete.`, "ok");
                        adminStatus.textContent = `Thumbnail generation completed.`;
                        resetUiState();
                        break;
                     case "cancelled":
                        log(`Thumbnail generation stopped by user.`, "warn");
                        adminStatus.textContent = `Thumbnail generation stopped.`;
                        resetUiState();
                        break;
                 }
            });

            await connection.start();
            await connection.invoke("JoinScan", data.scanId);
        } else {
            adminStatus.textContent = "Failed to start task.";
            startBtn.disabled = false;
            generateMissingThumbsBtn.disabled = false;
        }
    });
    cleanupTagsBtn.addEventListener("click", async () => {
          adminStatus.textContent = "Cleaning up tags...";
          cleanupTagsBtn.disabled = true;

          const resp = await fetch('/api/autotag/cleanup', { method: 'POST' });
          if (resp.ok) {
              const data = await resp.json();
              const message = `Cleanup complete. Scanned ${data.filesScanned} files and removed tag from ${data.filesCleaned}.`;
              adminStatus.textContent = message;
              log(message, "ok");
          } else {
              const errorText = await resp.text();
              adminStatus.textContent = "Failed to run cleanup task.";
              log(`Cleanup task failed: ${errorText}`, "err");
          }
          cleanupTagsBtn.disabled = false;
});
    // Initialize UI state on page load
    updateOptionStates();
</script>

@await Html.PartialAsync("_TopNavEnd")