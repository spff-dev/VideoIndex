@page "/scan"
@model VideoIndex.Web.Pages.Scan.IndexModel

@{
    ViewData["Title"] = "Live Scan";
}

@await Html.PartialAsync("_TopNav")

<div class="scan-page">
    <h1>Live Scan</h1>

    <div class="row">
      <label for="rootSelect">Root:</label>
      <select id="rootSelect">
        @foreach (var r in Model.Roots)
        {
          <option value="@r.Id">@r.Name (@r.Path)</option>
        }
      </select>
      <button id="startBtn">Start scan</button>
      <span id="status" class="muted">idle</span>
    </div>

    <div class="row" style="width:100%;">
      <progress id="prog" value="0" max="100" style="width: 360px;"></progress>
      <span id="counts" class="muted"></span>
    </div>

    <div class="row">
        </div>

    <pre id="log"></pre>
</div>


<script src="https://unpkg.com/%40microsoft/signalr@latest/dist/browser/signalr.min.js"></script>
<script>
  document.querySelector("#autoTagAllBtn")?.addEventListener("click", async () => {
    const dry = document.querySelector("#autoTagDryRun").checked;
    const batch = Math.max(50, Math.min(2000, parseInt(document.querySelector("#autoTagBatch").value || "500", 10)));
    const url = `/api/autotag/all?dryRun=${dry}&batchSize=${batch}`;
    const res = await fetch(url, { method: "POST" });
    const data = await res.json().catch(()=> ({}));
    const msg = res.ok
      ? `Auto-tag ${dry ? "(dry run)" : ""} complete.\nTotal: ${data.total ?? "?"}\nChanged: ${data.changed ?? "?"}\nUnchanged: ${data.unchanged ?? "?"}`
      : `Auto-tag failed: ${res.status}\n${JSON.stringify(data)}`;
    alert(msg);
  });
</script>

<pre id="log"></pre>

<script src="https://unpkg.com/%40microsoft/signalr@latest/dist/browser/signalr.min.js"></script>
<script>
  const base = location.origin;
  const $ = sel => document.querySelector(sel);
  const logEl = $("#log");
  const statusEl = $("#status");
  const countsEl = $("#counts");
  const progEl = $("#prog");
  const startBtn = $("#startBtn");

  const urlRoot = new URL(location.href).searchParams.get("root");
document.addEventListener("DOMContentLoaded", ()=>{
  if (urlRoot) {
    const sel = document.querySelector("#rootSelect");
    if (sel && [...sel.options].some(o => o.value === urlRoot)) sel.value = urlRoot;
  }
});

const autoAllBtn  = $("#autoAllBtn");
const autoDry     = $("#autoDry");
const autoBatch   = $("#autoBatch");
const autoStatus  = $("#autoStatus");

autoAllBtn?.addEventListener("click", async () => {
  try {
    autoAllBtn.disabled = true;
    autoStatus.textContent = "running…";
    log("Auto-tagging started… (this may take a while on large libraries)", "muted");

    const qs = new URLSearchParams({
      dryRun: String(autoDry.checked),
      batchSize: String(parseInt(autoBatch.value || "500", 10))
    });

    const resp = await fetch(`${base}/api/autotag/all?${qs.toString()}`, { method: "POST" });
    const data = await resp.json();

    if (!resp.ok) {
      log(`Auto-tag failed: ${resp.status} ${JSON.stringify(data)}`, "err");
      autoStatus.textContent = "error";
      return;
    }

    log(`Auto-tag summary — total: ${data.total}, changed: ${data.changed}, unchanged: ${data.unchanged}, dryRun: ${data.dryRun}`, "ok");
    autoStatus.textContent = "done";
  } catch (e) {
    log(`Auto-tag error: ${e}`, "err");
    autoStatus.textContent = "error";
  } finally {
    autoAllBtn.disabled = false;
  }
});

  function log(msg, cls="") {
    const time = new Date().toLocaleTimeString();
    const line = `[${time}] ${msg}\n`;
    const span = document.createElement("span");
    if (cls) span.className = cls;
    span.textContent = line;
    logEl.appendChild(span);
    logEl.scrollTop = logEl.scrollHeight;
  }

  function setStatus(txt) { statusEl.textContent = txt; }

  startBtn.addEventListener("click", async () => {
    startBtn.disabled = true;
    logEl.textContent = "";
    setStatus("connecting…");

    const rootId = parseInt($("#rootSelect").value, 10);
    const workers = Math.max(1, Math.min(24, parseInt($("#workers").value, 10) || 8));
    const thumbs = $("#thumbs").checked;
    const regenAll = $("#regenAll").checked;

    const scanId = (crypto && crypto.randomUUID) ? crypto.randomUUID() :
                   Math.random().toString(36).slice(2);

    const connection = new signalR.HubConnectionBuilder()
      .withUrl(`${base}/hubs/scan`)
      .withAutomaticReconnect()
      .configureLogging(signalR.LogLevel.Information)
      .build();

    let totalFiles = 0;
    let processed = 0;
    let indexed = 0;
    let thumbsMade = 0;
    let errors = 0;

    function updateCounts() {
      countsEl.textContent = `${processed} / ${totalFiles} processed, indexed: ${indexed}, thumbs: ${thumbsMade}, errors: ${errors}`;
    }

    connection.on("progress", evt => {
      switch (evt.kind) {
        case "started":
          totalFiles = evt.totals.files || 0;
          processed = 0; thumbsMade = 0; errors = 0; indexed = 0;
          progEl.max = Math.max(totalFiles, 1);
          progEl.value = 0;
          updateCounts();
          setStatus("running");
          log(`Scan started on "${evt.root.name}" (${evt.root.path}) — files: ${totalFiles}, thumbs: ${evt.totals.thumbsRequested ? "on" : "off"} (regenAll ${regenAll}), workers: ${workers}`, "muted");
          break;

        case "indexError":
          errors++;
          log(`Index error: ${evt.file} — ${evt.error}`, "err");
          break;

        case "thumbMade":
          thumbsMade++;
          log(`Thumb ✓ ${evt.file}`, "ok");
          break;

        case "thumbError":
          log(`Thumb error: ${evt.file} — ${evt.error}`, "warn");
          break;

        case "heartbeat":
          processed = evt.processed ?? processed;
          thumbsMade = evt.thumbsMade ?? thumbsMade;
          errors = evt.errors ?? errors;
          indexed = evt.indexed ?? indexed;
          progEl.value = processed;
          updateCounts();
          break;

        case "completed":
          processed = evt.processed ?? processed;
          thumbsMade = evt.thumbsMade ?? thumbsMade;
          errors = evt.errors ?? errors;
          indexed = evt.indexed ?? indexed;
          progEl.value = processed;
          updateCounts();
          setStatus("done");
          log(`Completed in ${evt.elapsedMs} ms — processed: ${processed}, indexed: ${indexed}, thumbs: ${thumbsMade}, errors: ${errors}`, "ok");
          startBtn.disabled = false;
          break;
      }
    });

    connection.onreconnecting(() => setStatus("reconnecting…"));
    connection.onreconnected(() => setStatus("running"));
    connection.onclose(() => { if (statusEl.textContent !== "done") setStatus("disconnected"); });

    try {
      await connection.start();
      await connection.invoke("JoinScan", scanId);
      log(`Joined scan channel ${scanId}`, "muted");

      // kick off the server-side scan
      const url = `${base}/api/roots/${rootId}/scan-live?scanId=${encodeURIComponent(scanId)}&thumbs=${thumbs}&regenAll=${regenAll}&dop=${workers}`;
      const resp = await fetch(url, { method: "POST" });
      if (!resp.ok) {
        const text = await resp.text();
        log(`Scan start failed: ${resp.status} ${text}`, "err");
        setStatus("error");
        startBtn.disabled = false;
      } else {
        const summary = await resp.json();
        log(`Scan request accepted — total files enumerated: ${summary.scanned}`, "muted");
      }
    } catch (e) {
      log(`SignalR error: ${e}`, "err");
      setStatus("error");
      startBtn.disabled = false;
    }
  });
</script>

@await Html.PartialAsync("_TopNavEnd")
