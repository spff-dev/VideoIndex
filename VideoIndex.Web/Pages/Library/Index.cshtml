@page "/library"
@model VideoIndex.Web.Pages.Library.IndexModel


@{
    ViewData["Title"] = "Library";
}

@await Html.PartialAsync("_TopNav")

<link rel="stylesheet" href="/css/tags.css" />

<style>
  .toolbar { display:grid; grid-template-columns: 1fr auto; gap:12px; align-items:end; margin-bottom:12px; }
  .filters { display:grid; grid-template-columns: repeat(3, minmax(0,1fr)); gap:12px; }
  .field { display:flex; flex-direction:column; gap:6px; }
  .hstack { display:flex; gap:.5rem; align-items:center; flex-wrap:wrap; }
  input[type="number"], select { padding:6px 8px; border:1px solid #ccc; border-radius:6px; font-size:14px; }
  .tagbtn { padding:6px 10px; border:1px solid #ccc; border-radius:999px; background:#f4f4f4; cursor:pointer; }
  .tagbtn.on { color:#fff; } /* group-specific .on backgrounds come from tags.css */
  .grid { display:grid; grid-template-columns: repeat(6, minmax(0,1fr)); gap:12px; }
  .card { border:1px solid #e2e2e2; border-radius:10px; padding:8px; display:flex; flex-direction:column; gap:6px; text-decoration:none; color:inherit;}
  .card .muted, .card .meta, .card .chip { text-decoration:none; }
  .thumb { width:100%; aspect-ratio:1/1; object-fit:contain; background:#1b1b1b; border-radius:6px; }
  .meta { font-size:.9rem; color:#555; display:flex; flex-wrap:wrap; gap:.35rem .5rem; }
  .chip { display:inline-flex; align-items:center; gap:.35rem; padding:.05rem .45rem; border:1px solid #ccc; border-radius:999px; font-size:.85rem; }
  .chip.clickable { cursor: pointer; }
  .chip.clickable:hover { filter: brightness(0.95); }
  .chip.meta { background:#111; border-color:#111; color:#fff; }
  .chip.filtered { filter:saturate(1.15) brightness(1.05); font-weight:600; }
  .muted { color:#777; }
  .btn { padding:8px 12px; border:1px solid #222; background:#222; color:#fff; border-radius:8px; cursor:pointer; }
  .btn[disabled] { opacity:.6; cursor:default; }
  .btn.ghost { background:#fff; color:#222; border-color:#ccc; }
  .countbar { display:flex; justify-content:space-between; align-items:center; margin:10px 0; }

  /* Group panels */
  .panel { padding:10px; border-radius:8px; border:1px solid transparent; }
  .panel.perf { background:#e6f3ea; border-color:#c9e6d2; }   /* greenish */
  .panel.ori  { background:#fff1e6; border-color:#ffd2a6; }   /* orange tint */
  .panel.src  { background:#e8f0fe; border-color:#c8ddff; }   /* blue tint */
  .panel.scan { background:#f7f7f7; border-color:#e3e3e3; }   /* light gray */

  /* Folder scope chip */
  .chip.folder { background:#e8f0fe; border-color:#c8ddff; }
  /* NEW: allow multi-line full paths */
  .chip.folder { max-width:100%; white-space:normal; overflow-wrap:anywhere; }
  .chip.folder .path { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
  .chip .x { border:0; background:transparent; cursor:pointer; font-size:1rem; line-height:1; padding:0 .25rem; }

  @@media (max-width: 1400px){ .grid { grid-template-columns: repeat(4, minmax(0,1fr)); } }
  @@media (max-width: 1000px){ .grid { grid-template-columns: repeat(3, minmax(0,1fr)); } }
  @@media (max-width: 700px){ .grid { grid-template-columns: repeat(2, minmax(0,1fr)); } }
</style>

<h1>Library</h1>

<div class="toolbar">
  <div id="filtersWrap" class="filters">
    <!-- Performer count -->
    <div class="field panel perf">
      <label>Performers</label>
      <div class="hstack">
        <input id="minPerf" type="number" min="0" placeholder="min" style="width:5rem">
        <input id="maxPerf" type="number" min="0" placeholder="max" style="width:5rem">
        <button type="button" class="tagbtn quick-perf" data-min="1" data-max="1">Solo</button>
        <button type="button" class="tagbtn quick-perf" data-min="2" data-max="2">Duo</button>
        <button type="button" class="tagbtn quick-perf" data-min="3" data-max="99">Group</button>
      </div>
    </div>

    <!-- Orientation -->
    <div class="field panel ori">
      <label>Orientation</label>
      <div class="hstack" id="oriGroup">
        <button type="button" class="tagbtn" data-ori="Gay">Gay</button>
        <button type="button" class="tagbtn" data-ori="Straight">Straight</button>
        <button type="button" class="tagbtn" data-ori="Bi">Bi</button>
        <button type="button" class="tagbtn" data-ori="FtM Trans">FtM Trans</button>
        <button type="button" class="tagbtn" data-ori="MtF Trans">MtF Trans</button>
      </div>
    </div>

    <!-- SourceType -->
    <div class="field panel src">
      <label>Source type</label>
      <div class="hstack" id="srcGroup">
        <button type="button" class="tagbtn" data-src="Studio">Studio</button>
        <button type="button" class="tagbtn" data-src="OnlyFans">OnlyFans</button>
        <button type="button" class="tagbtn" data-src="Amateur">Amateur</button>
        <button type="button" class="tagbtn" data-src="Vintage">Vintage</button>
        <button type="button" class="tagbtn" data-src="Webcam">Webcam</button>
        <button type="button" class="tagbtn" data-src="Spycam">Spycam</button>
        <button type="button" class="tagbtn" data-src="CCTV">CCTV</button>
        <button type="button" class="tagbtn" data-src="Selfie">Selfie</button>
        <button type="button" class="tagbtn" data-src="Social Media">Social Media</button>
        <button type="button" class="tagbtn" data-src="Animated">Animated</button>
        <button type="button" class="tagbtn" data-src="Unknown">Unknown</button>
      </div>
    </div>
  </div>

  <div class="field">
    <label>Search</label>
    <div class="hstack">
      <input id="searchBox" type="text" placeholder="Search filename, tags, performers, studio, year‚Ä¶" style="min-width:18rem">
      <button id="clearSearch" class="btn ghost" type="button" title="Clear">√ó</button>
    </div>

    <label style="margin-top:.75rem;">Sort</label>
    <select id="sortSel">
      <option value="updated_desc">Updated (newest)</option>
      <option value="updated_asc">Updated (oldest)</option>
      <option value="size_desc">Size (largest)</option>
      <option value="size_asc">Size (smallest)</option>
      <option value="length_desc">Length (longest)</option>
      <option value="length_asc">Length (shortest)</option>
      <option value="source_asc">Source (A‚ÜíZ)</option>
      <option value="source_desc">Source (Z‚ÜíA)</option>
      <option value="year_desc">Year (newest)</option>
      <option value="year_asc">Year (oldest)</option>
    </select>

    <div class="hstack" style="margin-top:.5rem;">
      <button id="toggleFilters" class="btn ghost" type="button">Hide filters</button>
      <button id="resetAll" class="btn ghost" type="button">Show all</button>
    </div>
  </div>
</div>

<!-- Active scope (folder) chip -->
<div id="scopeBar" class="hstack" style="margin:4px 0 10px 0;"></div>

<div class="countbar">
  <div><b id="totalCount">0</b> total</div>
  <div class="muted">Showing <span id="shownCount">0</span> of 36 per page</div>
</div>

<div id="grid" class="grid"></div>

<div style="margin-top:12px;">
  <button id="loadMore" class="btn">Load more</button>
  <span id="status" class="muted" style="margin-left:.5rem;"></span>
</div>

<!-- SignalR for scan progress -->
<script src="https://unpkg.com/%40microsoft/signalr@latest/dist/browser/signalr.min.js"></script>

<script>
  const $ = s => document.querySelector(s);
  const $$ = s => Array.from(document.querySelectorAll(s));

  const TAKE = 36;

  // ---- state ----
  let srcSel = new Set();
  let oriSel = new Set();
  let skip = 0;
  let total = 0;
  let filtersHidden = false;

  // ---- URL helpers ----
  function getParams(){
    const u = new URL(location.href);
    return u.searchParams;
  }
  function setParams(updates){
    const u = new URL(location.href);
    const sp = u.searchParams;
    // NOTE: do not clear 'dir' / 'recursive' here so they persist unless explicitly removed.
    ["source","orientation","minPerformers","maxPerformers","sort","skip","q"].forEach(k=>sp.delete(k));
    for (const [k,v] of Object.entries(updates)){
      if (v === null || v === undefined || v === "" || (Array.isArray(v) && v.length===0)) continue;
      if (Array.isArray(v)) sp.set(k, v.join(","));
      else sp.set(k, String(v));
    }
    history.replaceState({}, "", u.toString());
  }
  function clearFolderFilterInUrl(){
    const u = new URL(location.href);
    u.searchParams.delete("dir");
    u.searchParams.delete("recursive");
    history.replaceState({}, "", u.toString());
    renderScopeBar();
  }
  function getFolderFilterFromUrl(){
    const sp = getParams();
    const dir = sp.get("dir") || "";
    const recursive = (sp.get("recursive") || "false").toLowerCase() === "true";
    return { dir, recursive };
  }
  function basename(p){
    if (!p) return "";
    // handle both slashes
    const parts = p.split(/[\\/]+/).filter(Boolean);
    return parts.length ? parts[parts.length-1] : p;
  }

  function quickPerfMatches(btn){
    const min = btn.getAttribute('data-min') ?? "";
    const max = btn.getAttribute('data-max') ?? "";
    const curMin = ($("#minPerf").value ?? "").trim();
    const curMax = ($("#maxPerf").value ?? "").trim();
    return (min === curMin) && (max === curMax);
  }
  function updateQuickPerfButtons(){
    $$(".quick-perf").forEach(b=>{
      b.classList.toggle("on", quickPerfMatches(b));
    });
  }

  function readFromUrl(){
    const sp = getParams();
    (sp.get("source") || "").split(",").map(s=>s.trim()).filter(Boolean).forEach(v=>srcSel.add(v));
    (sp.get("orientation") || "").split(",").map(s=>s.trim()).filter(Boolean).forEach(v=>oriSel.add(v));
    const minP = sp.get("minPerformers"); const maxP = sp.get("maxPerformers");
    if (minP) $("#minPerf").value = minP;
    if (maxP) $("#maxPerf").value = maxP;
    const sort = sp.get("sort");
    if (sort) $("#sortSel").value = sort;
    skip = parseInt(sp.get("skip") || "0", 10); if (Number.isNaN(skip) || skip<0) skip = 0;
    const qInit = sp.get("q");
    if (qInit) $("#searchBox").value = qInit;
    $$("#srcGroup .tagbtn").forEach(b=> b.classList.toggle("on", srcSel.has(b.getAttribute("data-src"))));
    $$("#oriGroup .tagbtn").forEach(b=> b.classList.toggle("on", oriSel.has(b.getAttribute("data-ori"))));
    updateQuickPerfButtons();
  }

  // Normalize API item (supports camelCase or PascalCase)
  function norm(it){
    return {
      Id: it.Id ?? it.id,
      Filename: it.Filename ?? it.filename,
      SizeHuman: it.SizeHuman ?? it.sizeHuman,
      LengthHuman: it.LengthHuman ?? it.lengthHuman,
      Width: it.Width ?? it.width,
      Height: it.Height ?? it.height,
      Year: it.Year ?? it.year,
      PerformerCount: it.PerformerCount ?? it.performerCount,
      SourceTypes: it.SourceTypes ?? it.sourceTypes ?? [],
      OrientationTags: it.OrientationTags ?? it.orientationTags ?? [],
      OtherTags: it.OtherTags ?? it.otherTags ?? [],
      StudioName: it.StudioName ?? it.studioName,
      UpdatedAt: it.UpdatedAt ?? it.updatedAt,
      Thumb: it.Thumb ?? it.thumb
    };
  }

  // ---- rendering ----
  function card(raw){
    const item = norm(raw);

    const res = (item.Width && item.Height) ? `${item.Width}√ó${item.Height}` : "‚Äî";
    const len = item.LengthHuman ?? "‚Äî";
    const statsHtml = `
      <span class="chip meta">${escapeHtml(item.SizeHuman)}</span>
      <span class="chip meta">Len: ${len}</span>
      <span class="chip meta">Res: ${res}</span>
    `;

    const oriHtml = (item.OrientationTags || [])
      .filter(Boolean)
      .map(t=>{
        const filtered = oriSel.has(t) ? " filtered" : "";
        return `<span class="chip ori clickable${filtered}" data-ori="${escapeHtml(t)}">${escapeHtml(t)}</span>`;
      })
      .join(" ");

    const pc = item.PerformerCount;
    const perfBadge = badgeFromCountForCard(pc);
    const perfFiltered = isPerformerFilterActiveFor(pc) ? " filtered" : "";
    const perfHtml = (pc != null)
      ? (pc === 1
          ? `<span class="chip perf clickable${perfFiltered}" data-min="1" data-max="1">${perfBadge}</span>`
          : pc === 2
            ? `<span class="chip perf clickable${perfFiltered}" data-min="2" data-max="2">${perfBadge}</span>`
            : `<span class="chip perf clickable${perfFiltered}" data-min="3" data-max="99">${perfBadge}</span>`)
      : "";

    const srcHtml = (item.SourceTypes || [])
      .filter(Boolean)
      .map(t=>{
        const filtered = srcSel.has(t) ? " filtered" : "";
        return `<span class="chip src clickable${filtered}" data-src="${escapeHtml(t)}">${escapeHtml(t)}</span>`;
      })
      .join(" ");

    return `
      <a class="card" href="/media/${item.Id}">
        <img class="thumb" src="${item.Thumb}" alt="thumb" loading="lazy" onerror="this.style.display='none'">
        <div class="muted">${escapeHtml(item.Filename)}</div>

        <div class="meta">${statsHtml}</div>

        <div class="meta">
          ${oriHtml}
          ${perfHtml}
          ${srcHtml}
        </div>
      </a>`;
  }

  function badgeFromCountForCard(pc){
    if (pc === 1) return "Solo";
    if (pc === 2) return "Duo";
    if (pc >= 3) return "Group";
    return "‚Äî";
  }
  function isPerformerFilterActiveFor(pc){
    const minP = ($("#minPerf").value ?? "").trim();
    const maxP = ($("#maxPerf").value ?? "").trim();
    if (!minP && !maxP) return false;
    const min = parseInt(minP || "NaN", 10);
    const max = parseInt(maxP || "NaN", 10);
    if (Number.isNaN(pc)) return false;
    if (min === 1 && max === 1) return pc === 1;
    if (min === 2 && max === 2) return pc === 2;
    if (min >= 3 && (!maxP || (!Number.isNaN(max) && max >= 3))) return pc >= 3;
    return false;
  }

  function escapeHtml(s){
    s = (s ?? "").toString();
    return s.replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'}[c]));
  }

  function updateCounts(shownAdd){
    const shown = Math.min(skip + shownAdd, total);
    $("#shownCount").textContent = Math.min(shown, TAKE);
    $("#totalCount").textContent = total;
  }

  function renderScopeBar(){
    const { dir, recursive } = getFolderFilterFromUrl();
    const bar = $("#scopeBar");
    if (!bar) return;                 // ensure the container exists
    bar.innerHTML = "";
    if (!dir) return;

    const chip = document.createElement("span");
    chip.className = "chip folder";
    chip.title = dir;

    // insert zero-width spaces after / or \ so the path can wrap
    const breakable = escapeHtml(dir).replace(/([\\/])/g, '$1&#8203;'); // &#8203; = ZWSP

    chip.innerHTML =
      `üìÅ <span class="path">${breakable}</span>` +
      (recursive ? " (all subfolders)" : "") +
      ` <button type="button" id="clearFolderFilter" class="x" title="Clear folder filter">√ó</button>`;

    bar.appendChild(chip);

    // clear button
    $("#clearFolderFilter")?.addEventListener("click", () => {
      const u = new URL(location.href);
      u.searchParams.delete("dir");
      u.searchParams.delete("recursive");
      history.replaceState({}, "", u.toString());
      reload(true);
    });
  }

  // ---- fetch ----
  async function fetchPage(append=false){
    $("#status").textContent = "loading‚Ä¶";
    $("#loadMore").disabled = true;

    const params = new URLSearchParams();
    params.set("skip", String(skip));
    params.set("take", String(TAKE));

    const q = ($("#searchBox").value ?? "").trim();
    if (q) params.set("q", q);

    if (srcSel.size) params.set("source", [...srcSel].join(","));
    if (oriSel.size) params.set("orientation", [...oriSel].join(","));

    const minP = $("#minPerf").value.trim();
    const maxP = $("#maxPerf").value.trim();
    if (minP) params.set("minPerformers", minP);
    if (maxP) params.set("maxPerformers", maxP);

    params.set("sort", $("#sortSel").value);

    // NEW: pass folder scope to API
    const { dir, recursive } = getFolderFilterFromUrl();
    if (dir) {
      params.set("dir", dir);
      params.set("recursive", recursive ? "true" : "false");
    }

    const url = `/api/media/browse?${params.toString()}`;
    try {
      const res = await fetch(url);
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      const data = await res.json();
      total = data.total ?? 0;

      const grid = $("#grid");
      if (!append) grid.innerHTML = "";
      const html = (data.items || []).map(card).join("");
      grid.insertAdjacentHTML("beforeend", html);

      $("#loadMore").disabled = (skip + TAKE >= total);
      $("#status").textContent = (skip + TAKE >= total) ? "end of results" : "";
      updateCounts(data.items?.length ?? 0);
    } catch (e) {
      $("#status").textContent = "error: " + (e.message || e);
    }
  }

  function reload(resetSkip=true){
    if (resetSkip) skip = 0;
    setParams({
      source: [...srcSel],
      orientation: [...oriSel],
      minPerformers: $("#minPerf").value.trim() || null,
      maxPerformers: $("#maxPerf").value.trim() || null,
      sort: $("#sortSel").value,
      q: ($("#searchBox").value ?? "").trim() || null,
      skip
    });
    renderScopeBar();
    fetchPage(false);
  }

  function toggleFilters(){
    const wrap = $("#filtersWrap");
    filtersHidden = !filtersHidden;
    if (filtersHidden) {
      wrap.setAttribute("hidden", "hidden");
      $("#toggleFilters").textContent = "Show filters";
    } else {
      wrap.removeAttribute("hidden");
      $("#toggleFilters").textContent = "Hide filters";
    }
  }

  function resetAll(){
    srcSel.clear();
    oriSel.clear();
    $("#minPerf").value = "";
    $("#maxPerf").value = "";
    $("#sortSel").value = "updated_desc";
    $("#searchBox").value = "";
    $$("#srcGroup .tagbtn").forEach(b=> b.classList.remove("on"));
    $$("#oriGroup .tagbtn").forEach(b=> b.classList.remove("on"));
    updateQuickPerfButtons();
    clearFolderFilterInUrl(); // also clear folder scope
    reload(true);
  }

  function debounce(fn, ms){ let t; return function(...args){ clearTimeout(t); t=setTimeout(()=>fn.apply(this,args), ms); }; }
  function scrollTopSmooth(){ window.scrollTo({ top: 0, behavior: 'smooth' }); }

  // ---------- Mini Scan: client ----------
  const scan = {
    connection: null,
    roots: [],
    overallTotal: 0,
    processedSoFar: 0,
    currentRootTotal: 0,

    log(msg, cls){
      const pre = $("#scanLog");
      const time = new Date().toLocaleTimeString();
      const line = `[${time}] ${msg}\n`;
      const span = document.createElement("span");
      if (cls) span.className = cls;
      span.textContent = line;
      pre.appendChild(span);
      pre.scrollTop = pre.scrollHeight;
    },

    setStatus(s){ $("#scanStatus").textContent = s; },
    updateCounts(proc, total, indexed, thumbsMade, errors){
      $("#scanCounts").textContent = `${proc} / ${total} processed ‚Ä¢ indexed: ${indexed} ‚Ä¢ thumbs: ${thumbsMade} ‚Ä¢ errors: ${errors}`;
      const prog = $("#scanProg");
      prog.max = Math.max(total, 1);
      prog.value = Math.min(proc, total);
    },

    async getRoots(){
      const r = await fetch("/api/roots");
      if (!r.ok) throw new Error("Failed to fetch roots");
      return await r.json();
    },

    async dryRunAll(roots){
      let sum = 0;
      await Promise.all(roots.map(async (rt)=>{
        try{
          const res = await fetch(`/api/roots/${rt.id}/scan-dry-run`);
          if (!res.ok) return;
          const js = await res.json();
          sum += (js.discovered || 0);
        }catch{}
      }));
      return sum;
    },

    async start(){
      $("#btnScanAll").disabled = true;
      $("#scanLog").textContent = "";
      this.setStatus("preparing‚Ä¶");

      const workers = Math.max(1, Math.min(24, parseInt($("#scanWorkers").value, 10) || 8));
      const thumbs = $("#scanThumbs").checked;
      const regenAll = $("#scanRegenAll").checked;

      try{
        this.roots = await this.getRoots();
      }catch(e){
        this.log(`Failed to fetch roots: ${e}`, "err");
        this.setStatus("error");
        $("#btnScanAll").disabled = false;
        return;
      }
      if (!this.roots || this.roots.length === 0){
        this.log("No roots configured.", "warn");
        this.setStatus("idle");
        $("#btnScanAll").disabled = false;
        return;
      }

      this.overallTotal = await this.dryRunAll(this.roots);
      this.processedSoFar = 0;
      this.currentRootTotal = 0;

      const base = location.origin;
      const scanId = (crypto && crypto.randomUUID) ? crypto.randomUUID() : Math.random().toString(36).slice(2);
      this.connection = new signalR.HubConnectionBuilder()
        .withUrl(`${base}/hubs/scan`)
        .withAutomaticReconnect()
        .configureLogging(signalR.LogLevel.Information)
        .build();

      let curIndexed = 0, curThumbs = 0, curErrors = 0;

      this.connection.on("progress", evt => {
        switch (evt.kind) {
          case "started": {
            if (!this.overallTotal || this.overallTotal <= 0) {
              this.overallTotal += (evt.totals.files || 0);
            }
            this.currentRootTotal = evt.totals.files || 0;
            this.setStatus(`running ‚Äî ${evt.root.name}`);
            this.log(`Scan started on "${evt.root.name}" (${evt.root.path}) ‚Äî files: ${this.currentRootTotal}, thumbs: ${evt.totals.thumbsRequested ? "on" : "off"} (regenAll ${regenAll}), workers: ${workers}`, "muted");
            break;
          }
          case "indexError":
            curErrors++;
            this.log(`Index error: ${evt.file} ‚Äî ${evt.error}`, "err");
            break;
          case "thumbMade":
            curThumbs++;
            this.log(`Thumb ‚úì ${evt.file}`, "ok");
            break;
          case "thumbError":
            this.log(`Thumb error: ${evt.file} ‚Äî ${evt.error}`, "warn");
            break;
          case "heartbeat": {
            const processed = (evt.processed ?? 0);
            curIndexed = evt.indexed ?? curIndexed;
            curThumbs = evt.thumbsMade ?? curThumbs;
            curErrors = evt.errors ?? curErrors;
            const overallProc = this.processedSoFar + processed;
            this.updateCounts(overallProc, this.overallTotal, curIndexed, curThumbs, curErrors);
            break;
          }
          case "completed": {
            const processed = (evt.processed ?? this.currentRootTotal);
            curIndexed = evt.indexed ?? curIndexed;
            curThumbs = evt.thumbsMade ?? curThumbs;
            curErrors = evt.errors ?? curErrors;
            this.processedSoFar += processed;
            const overallProc = this.processedSoFar;
            this.updateCounts(overallProc, this.overallTotal, curIndexed, curThumbs, curErrors);
            this.log(`Completed "${evt.root?.name ?? "root"}" in ${evt.elapsedMs} ms ‚Äî processed: ${processed}, indexed: ${curIndexed}, thumbs: ${curThumbs}, errors: ${curErrors}`, "ok");
            break;
          }
        }
      });

      this.connection.onreconnecting(() => this.setStatus("reconnecting‚Ä¶"));
      this.connection.onreconnected(() => this.setStatus("running"));
      this.connection.onclose(() => {
        if ($("#scanStatus").textContent !== "done") this.setStatus("disconnected");
      });

      try {
        await this.connection.start();
        await this.connection.invoke("JoinScan", scanId);
        this.log(`Joined scan channel ${scanId}`, "muted");
      } catch (e) {
        this.log(`SignalR error: ${e}`, "err");
        this.setStatus("error");
        $("#btnScanAll").disabled = false;
        return;
      }

      for (let i=0; i<this.roots.length; i++){
        const r = this.roots[i];
        this.log(`‚Üí Starting root ${i+1}/${this.roots.length}: ${r.name}`, "muted");
        const url = `${base}/api/roots/${r.id}/scan-live?scanId=${encodeURIComponent(scanId)}&thumbs=${thumbs}&regenAll=${regenAll}&dop=${encodeURIComponent($("#scanWorkers").value)}`;
        try{
          const resp = await fetch(url, { method:"POST" });
          if (!resp.ok){
            const txt = await resp.text();
            this.log(`Scan failed on root "${r.name}": ${resp.status} ${txt}`, "err");
            this.setStatus("error");
            break;
          } else {
            const summary = await resp.json();
            this.log(`Root "${r.name}" request completed ‚Äî discovered: ${summary.scanned}`, "muted");
          }
        }catch(e){
          this.log(`Network error for root "${r.name}": ${e}`, "err");
          this.setStatus("error");
          break;
        }
      }

      this.setStatus("done");
      $("#btnScanAll").disabled = false;
    }
  };

  // ---------- page init ----------
  document.addEventListener("DOMContentLoaded", () => {
    // Library init
    readFromUrl();
    renderScopeBar();
    reload(false);

    $("#scopeBar").addEventListener("click", (e)=>{
      const btn = e.target.closest("#clearFolderFilter");
      if (!btn) return;
      clearFolderFilterInUrl();
      reload(true);
    });

    $("#oriGroup").addEventListener("click", (e)=>{
      const btn = e.target.closest('.tagbtn'); if (!btn) return;
      const v = btn.getAttribute("data-ori");
      if (btn.classList.contains("on")) { btn.classList.remove("on"); oriSel.delete(v); }
      else { btn.classList.add("on"); oriSel.add(v); }
      reload();
    });

    $("#srcGroup").addEventListener("click", (e)=>{
      const btn = e.target.closest('.tagbtn'); if (!btn) return;
      const v = btn.getAttribute("data-src");
      if (btn.classList.contains("on")) { btn.classList.remove("on"); srcSel.delete(v); }
      else { btn.classList.add("on"); srcSel.add(v); }
      reload();
    });

    // Clickable chips on cards ‚Üí apply filter and reload
    $("#grid").addEventListener("click", (e)=>{
      const chip = e.target.closest(".chip.clickable");
      if (!chip) return;

      const vSrc = chip.dataset.src;
      const vOri = chip.dataset.ori;
      let changed = false;

      if (vSrc && !srcSel.has(vSrc)) {
        srcSel.add(vSrc);
        $(`#srcGroup .tagbtn[data-src="${CSS.escape(vSrc)}"]`)?.classList.add("on");
        changed = true;
      }
      if (vOri && !oriSel.has(vOri)) {
        oriSel.add(vOri);
        $(`#oriGroup .tagbtn[data-ori="${CSS.escape(vOri)}"]`)?.classList.add("on");
        changed = true;
      }

      if (chip.classList.contains("perf")) {
        const min = chip.getAttribute("data-min") || "";
        const max = chip.getAttribute("data-max") || "";
        if ($("#minPerf").value !== min || $("#maxPerf").value !== max) {
          $("#minPerf").value = min;
          $("#maxPerf").value = max;
          updateQuickPerfButtons();
          changed = true;
        }
      }

      if (changed) reload();
      e.preventDefault();
      e.stopPropagation();
    });

    document.addEventListener("click", (e)=>{
      const b = e.target.closest('.quick-perf'); if (!b) return;
      $("#minPerf").value = b.getAttribute("data-min");
      $("#maxPerf").value = b.getAttribute("data-max");
      updateQuickPerfButtons();
      scrollTopSmooth();
      reload();
    });

    $("#minPerf").addEventListener("change", ()=> { reload(); updateQuickPerfButtons(); });
    $("#maxPerf").addEventListener("change", ()=> { reload(); updateQuickPerfButtons(); });

    $("#sortSel").addEventListener("change", ()=> reload());

    const onSearch = debounce(()=> reload(), 300);
    $("#searchBox").addEventListener("input", onSearch);
    $("#clearSearch").addEventListener("click", ()=>{
      $("#searchBox").value = "";
      reload();
    });

    $("#loadMore").addEventListener("click", ()=>{
      skip += TAKE;
      setParams({
        source: [...srcSel],
        orientation: [...oriSel],
        minPerformers: $("#minPerf").value.trim() || null,
        maxPerformers: $("#maxPerf").value.trim() || null,
        sort: $("#sortSel").value,
        q: ($("#searchBox").value ?? "").trim() || null,
        skip
      });
      fetchPage(true);
    });

    $("#toggleFilters").addEventListener("click", toggleFilters);
    $("#resetAll").addEventListener("click", resetAll);

    // Mini scan wiring (guard for missing elements)
    $("#btnScanAll")?.addEventListener("click", () => scan.start());
    $("#toggleScanLog")?.addEventListener("click", ()=>{
      const pre = $("#scanLog");
      if (!pre) return;
      const shown = pre.style.display !== "none";
      pre.style.display = shown ? "none" : "block";
      $("#toggleScanLog").textContent = shown ? "Show log" : "Hide log";
    });
  });
</script>

@await Html.PartialAsync("_TopNavEnd")
